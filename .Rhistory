peps_removed_prop <- ((peps_removed / original_peps) * 100) %>%
round(digits = 2)
## Determine number and proportion of proteins removed
prots_remaining <- cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Master.Protein.Accessions) %>%
unique() %>%
length() %>%
as.numeric()
prots_removed <- original_prots - prots_remaining
prots_removed_prop <- ((prots_removed / original_prots) * 100) %>%
round(digits = 2)
## Print as a table
data.frame("Feature" = c("PSMs",
"Peptides",
"Proteins"),
"Number lost" = c(psms_removed,
peps_removed,
prots_removed),
"Percentage lost" = c(psms_removed_prop,
peps_removed_prop,
prots_removed_prop))
## Determine number and proportion of PSMs removed
psms_remaining <- cp_qf[["psms_filtered"]] %>%
nrow() %>%
as.numeric()
psms_removed <- original_psms - psms_remaining
psms_removed_prop <- ((psms_removed / original_psms) * 100) %>%
round(digits = 2)
## Determine number and proportion of peptides removed
peps_remaining <- cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Sequence) %>%
unique() %>%
length() %>%
as.numeric()
peps_removed <- original_peps - peps_remaining
peps_removed_prop <- ((peps_removed / original_peps) * 100) %>%
round(digits = 2)
## Determine number and proportion of proteins removed
prots_remaining <- cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Master.Protein.Accessions) %>%
unique() %>%
length() %>%
as.numeric()
prots_removed <- original_prots - prots_remaining
prots_removed_prop <- ((prots_removed / original_prots) * 100) %>%
round(digits = 2)
## Get summary information
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Average.Reporter.SN) %>%
summary()
## Drop these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ Average.Reporter.SN >= 10,
na.rm = TRUE,
i = "psms_filtered")
## Remove these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ Isolation.Interference.in.Percent <= 75,
na.rm = TRUE,
i = "psms_filtered")
## Find out how many PSMs we expect to lose
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
dplyr::count(SPS.Mass.Matches.in.Percent < 65)
## Drop these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ SPS.Mass.Matches.in.Percent >= 65,
na.rm = TRUE,
i = "psms_filtered")
## Determine whether there are any NA values in the data
cp_qf[["psms_filtered"]] %>%
assay() %>%
anyNA()
## Determine the amount and distribution of NA values in the data
cp_qf[["psms_filtered"]] %>%
nNA()
## Plot histogram to visualize the distribution of NAs
nNA(cp_qf[["psms_filtered"]])$nNAcols %>%
as_tibble() %>%
mutate(Condition = rep(c("Treated", "Control"), each = 3)) %>%
ggplot(aes(x = name, y = pNA, group = Condition, fill = Condition)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Sample", y = "Proportion missing values") +
theme_bw()
## Plot histogram to visualize the distribution of NAs
nNA(cp_qf[["psms_filtered"]])$nNAcols %>%
as_tibble() %>%
mutate(Condition = rep(c("Treated", "Control"), each = 3)) %>%
ggplot(aes(x = name, y = (pNA * 100 ), group = Condition, fill = Condition)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Sample", y = "Missing values (%)") +
theme_bw()
## Find out the range of missing values per PSM
nNA(cp_qf[["psms_filtered"]])$nNArows$nNA %>%
table()
## Get indices of rows which contain NA
rows_with_na_indices <- which(nNA(cp_qf[["psms_filtered"]])$nNArows$nNA != 0)
## Subset rows with NA
rows_with_na <- cp_qf[["psms_filtered"]][rows_with_na_indices, ]
## Inspect rows with NA
assay(rows_with_na)
## Check how many PSMs we will remove
nNA(cp_qf[["psms_filtered"]])$nNArows %>%
as_tibble() %>%
dplyr::count(pNA >= 0.2)
## Remove PSMs with more than 20 % (0.2) NA values
cp_qf <- cp_qf %>%
filterNA(pNA = 0.2,
i = "psms_filtered")
## log2 transform quantitative data
cp_qf <- logTransform(object = cp_qf,
base = 2,
i = "psms_filtered",
name = "log_psms")
## Verify
cp_qf
## Aggregate PSM to peptide
cp_qf <- aggregateFeatures(cp_qf,
i = "log_psms",
fcol = "Sequence",
name = "log_peptides",
fun = MsCoreUtils::robustSummary,
na.rm = TRUE)
## Verify
cp_qf
## Confirm the presence of NaN
assay(cp_qf[["log_peptides"]]) %>%
is.nan() %>%
table()
## Replace NaN with NA
assay(cp_qf[["log_peptides"]])[is.nan(assay(cp_qf[["log_peptides"]]))] <- NA
## Aggregate peptides to protein
cp_qf <- aggregateFeatures(cp_qf,
i = "log_peptides",
fcol = "Master.Protein.Accessions",
name = "log_proteins",
fun = MsCoreUtils::robustSummary,
na.rm = TRUE)
## Verify
cp_qf
## normalize the log transformed peptide data
cp_qf <- normalize(cp_qf,
i = "log_proteins",
name = "log_norm_proteins",
method = "center.median")
## Verify
cp_qf
## Evaluate the effect of data normalization
pre_norm <- cp_qf[["log_proteins"]] %>%
assay() %>%
longFormat() %>%
mutate(Condition = ifelse(colname %in% c("S1", "S2", "S3"),
"Treated", "Control")) %>%
ggplot(aes(x = colname, y = value, fill = Condition)) +
geom_boxplot() +
labs(x = "Sample", y = "log2(abundance)", title = "Pre-normalization") +
theme_bw()
post_norm <- cp_qf[["log_norm_proteins"]] %>%
assay() %>%
longFormat() %>%
mutate(Condition = ifelse(colname %in% c("S1", "S2", "S3"),
"Treated", "Control")) %>%
ggplot(aes(x = colname, y = value, fill = Condition)) +
geom_boxplot() +
labs(x = "Sample", y = "log2(abundance)", title = "Post-normalization") +
theme_bw()
(pre_norm + theme(legend.position = "none")) +
post_norm & plot_layout(guides = "collect")
## visualize the process of log transformation and normalization
par(mfrow = c(1, 3))
cp_qf[["psms_filtered"]] %>%
assay() %>%
plotDensities(legend = "topright",
main = "Raw PSMs")
cp_qf[["log_psms"]] %>%
assay() %>%
plotDensities(legend = FALSE,
main = "log2(PSMs)")
cp_qf[["log_norm_proteins"]] %>%
assay() %>%
plotDensities(legend = FALSE,
main = "log2(norm proteins)")
## Add assay links from log_norm_proteins to psms_raw
cp_qf <- addAssayLink(object = cp_qf,
from = "psms_raw",
to = "log_norm_proteins",
varFrom = "Master.Protein.Accessions",
varTo = "Master.Protein.Accessions")
## Verify
assayLink(cp_qf,
i = "log_norm_proteins")
## Subset all data linked to the protein with accession Q01581
Q01581 <- subsetByFeature(cp_qf, "Q01581")
## Verify
Q01581
## Define conditions
treament <- c("S1", "S2", "S3")
control <- c("S4", "S5", "S6")
## Plot abundance distributions across samples at PSM, peptide and protein-level
Q01581[, , c("log_psms", "log_peptides", "log_proteins")] %>%
longFormat() %>%
as_tibble() %>%
mutate(assay_order = factor(
assay,
levels = c("log_psms", "log_peptides", "log_proteins"),
labels = c("PSMs", "Peptides", "Protein")),
condition = ifelse(colname %in% control, "control", "treatment")) %>%
ggplot(aes(x = colname, y = value, colour = assay)) +
geom_point(size = 3) +
geom_line(aes(group = rowname)) +
scale_x_discrete(limits = paste0("S", 1:6)) +
facet_wrap(~assay_order) +
labs(x = "Sample", y = "Abundance") +
ggtitle("log2 Q01581 abundance profiles") +
theme_bw()
## Locate the PeptideGroups .txt file
sn_peptide <- "supernatant_lfq_results_peptides.txt"
## Import into a data.frame
sn_df <- read.delim(sn_peptide)
## Create QFeatures object
sn_qf <- readQFeatures(assayData = sn_df,
quantCols = 21:26,
name = "peptides_raw")
## Clean sample names
colnames(sn_qf[["peptides_raw"]]) <- paste0("S", 1:6)
## Annotate samples
sn_qf$sample <- paste0("S", 1:6)
sn_qf$condition <- rep(c("Treated", "Control"), each = 3)
## Verify and allocate colData to initial SummarizedExperiment
colData(sn_qf)
colData(sn_qf[["peptides_raw"]]) <- colData(sn_qf)
## Find out what information was imported
sn_qf[["peptides_raw"]] %>%
rowData() %>%
colnames()
## Determine the number of PSMs
original_psms <- sn_qf[["peptides_raw"]] %>%
rowData() %>%
as_tibble() %>%
pull(Number.of.PSMs) %>%
sum()
## Determine the number of peptides
original_peps <- sn_qf[["peptides_raw"]] %>%
rowData() %>%
as_tibble() %>%
pull(Sequence) %>%
unique() %>%
length() %>%
as.numeric()
## Determine the number of proteins
original_prots <- sn_qf[["peptides_raw"]] %>%
rowData() %>%
as_tibble() %>%
pull(Master.Protein.Accessions) %>%
unique() %>%
length() %>%
as.numeric()
## View
original_psms
original_peps
original_prots
## Check missed cleavages
sn_qf[["peptides_raw"]] %>%
rowData() %>%
as_tibble() %>%
pull(Number.of.Missed.Cleavages) %>%
table()
## Add second copy of data to be filtered
data_copy <- sn_qf[["peptides_raw"]]
sn_qf <- addAssay(x = sn_qf,
y = data_copy,
name = "peptides_filtered")
## Verify
sn_qf
## Store row indices of peptides matched to a contaminant-containing protein group
cont_peptides <- find_cont(sn_qf[["peptides_filtered"]], cont_acc)
## Remove these rows from the data
if (length(cont_peptides) > 0)
sn_qf[["peptides_filtered"]] <- sn_qf[["peptides_filtered"]][-cont_peptides, ]
sn_qf <- sn_qf %>%
filterFeatures(~ !Master.Protein.Accessions == "",
i = "peptides_filtered") %>%
filterFeatures(~ !Quan.Info == "NoQuanValues",
i ="peptides_filtered") %>%
filterFeatures(~ !Quan.Info == "NoneMonoisotopic",
i = "peptides_filtered") %>%
filterFeatures(~ Number.of.Protein.Groups == 1,
i = "peptides_filtered") %>%
filterFeatures(~ Rank.by.Search.Engine.Sequest.HT == 1,
i = "peptides_filtered") %>%
filterFeatures(~ PSM.Ambiguity == "Unambiguous",
i = "peptides_filtered")
## Check for remaining annotations
sn_qf[["peptides_filtered"]] %>%
rowData %>%
as_tibble() %>%
pull(Quan.Info) %>%
table()
protein_sn <- read.delim(file = "supernatant_lfq_results_proteins.txt")
## Extract master protein accessions from our PSM-level data
proteins_in_data <- sn_qf[["peptides_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Master.Protein.Accessions)
## Extract protein accessions and corresponding confidence from search output file
protein_search_output <- protein_sn %>%
select(Accession, Protein.FDR.Confidence.Combined)
## Extract master protein accessions from our PSM-level data
proteins_in_data <- sn_qf[["peptides_filtered"]] %>%
rowData() %>%
as_tibble() %>%
select(Master.Protein.Accessions)
## Combine data
protein_fdr <- left_join(x = proteins_in_data,
y = protein_search_output,
by = c("Master.Protein.Accessions" = "Accession"))
protein_fdr %>%
head()
rowData(sp_qf[["peptides_filtered"]])$Protein.Confidence <- protein_fdr$Protein.FDR.Confidence.Combined
rowData(sn_qf[["peptides_filtered"]])$Protein.Confidence <- protein_fdr$Protein.FDR.Confidence.Combined
sn_qf <- sn_qf %>%
filterFeatures(~ Protein.Confidence == "High", i = "peptides_filtered")
## Determine number of PSMs, peptides and proteins remaining
psms_remaining <- sn_qf[["peptides_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Number.of.PSMs) %>%
sum()
peps_remaining <- sn_qf[["peptides_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Sequence) %>%
unique() %>%
length() %>%
as.numeric()
prots_remaining <- sn_qf[["peptides_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Master.Protein.Accessions) %>%
unique() %>%
length() %>%
as.numeric()
## Determine the number of proportion of PSMs, peptides and proteins removed
psms_removed <- original_psms - psms_remaining
psms_removed_prop <- ((psms_removed /original_psms) * 100) %>%
round(digits = 2)
peps_removed <- original_peps - peps_remaining
peps_removed_prop <- ((peps_removed / original_peps) * 100) %>%
round(digits = 2)
prots_removed <- original_prots - prots_remaining
prots_removed_prop <- ((prots_removed / original_prots) * 100) %>%
round(digits = 2)
## Present in a table
data.frame("Feature" = c("PSMs",
"Peptides",
"Proteins"),
"Number lost" = c(psms_removed,
peps_removed,
prots_removed),
"Percentage lost" = c(psms_removed_prop,
peps_removed_prop,
prots_removed_prop),
"Number remaining" = c(psms_remaining,
peps_remaining,
prots_remaining))
## Are there any NA values within the peptide data?
sn_qf[["peptides_filtered"]] %>%
assay() %>%
anyNA()
## How many NA values are there within the peptide data?
sn_qf[["peptides_filtered"]] %>%
nNA()
## Plot histogram to visualize sample-specific distribution of NAs
nNA(sn_qf[["peptides_filtered"]])$nNAcols %>%
as_tibble() %>%
mutate(Condition = rep(c("Treated", "Control"), each = 3)) %>%
ggplot(aes(x = name, y = (pNA * 100), group = Condition, fill = Condition)) +
geom_bar(stat = "identity") +
labs(x = "Sample", y = "Missing values (%)") +
theme_bw()
## Check how many peptides we will remove
which(nNA(sn_qf[["peptides_filtered"]])$nNArows$pNA >= 0.2) %>%
length()
## Remove peptides with 2 or more NA values
sn_qf <- sn_qf %>%
filterNA(pNA = 0.2,
i = "peptides_filtered")
nNA(sn_qf[["peptides_filtered"]])$nNA
## Find out available imputation methods
MsCoreUtils::imputeMethods()
## Impute missing values using kNN
sn_qf <- impute(sn_qf,
method = "knn",
i = "peptides_filtered",
name = "peptides_imputed")
## visualize the impact of imputation
par(mfrow = c(1, 2))
sn_qf[["peptides_filtered"]] %>%
assay() %>%
log2() %>%
plotDensities(main = "Pre-imputation",
legend = FALSE)
sn_qf[["peptides_imputed"]] %>%
assay() %>%
log2() %>%
plotDensities(main = "Post-imputation",
legend = "topright")
## log2 transform the quantitative data
sn_qf <- logTransform(object = sn_qf,
base = 2,
i = "peptides_imputed",
name = "log_peptides")
## Verify
sn_qf
## Aggregate peptide to protein
sn_qf <- aggregateFeatures(sn_qf,
i = "log_peptides",
fcol = "Master.Protein.Accessions",
name = "log_proteins",
fun = MsCoreUtils::robustSummary,
na.rm = TRUE)
## Verify
sn_qf
## normalize protein-level quantitation data
sn_qf <- normalize(sn_qf,
i = "log_proteins",
name = "log_norm_proteins",
method = "center.median")
## Verify
sn_qf
## Convert TMT CP protein assay into a dataframe
prot_df <- cp_qf[["log_norm_proteins"]] %>%
assay() %>%
as.data.frame()
## Calculate a correlation matrix between samples
corr_matrix <- cor(prot_df,
method = "pearson",
use = "pairwise.complete.obs")
print(corr_matrix)
## Plot correlation between two samples - S1 and S2 used as example
prot_df %>%
ggplot(aes(x = `S1`, y = `S2`)) +
geom_point(colour = "grey45", size = 0.5) +
geom_abline(intercept = 0, slope = 1) +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
plot.background = element_rect(fill = "white"),
panel.background = element_rect(fill = "white"),
axis.title.x = element_text(size = 15, vjust = -2),
axis.title.y = element_text(size = 15, vjust = 3),
axis.text.x = element_text(size = 12, vjust = -1),
axis.text.y = element_text(size = 12),
axis.line = element_line(linewidth = 0.5, colour = "black"),
plot.margin = margin(10, 10, 10, 10)) +
xlim(-7.5, 5) +
ylim(-7.5, 5) +
labs(x = "log2(abundance S1)", y = "log2(abundance S2)") +
coord_fixed(ratio = 1)
## Create colour palette for continuum
col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF",
"#77AADD", "#4477AA"))
## Plot all pairwise correlations
prot_df %>%
cor(method = "pearson",
use = "pairwise.complete.obs") %>%
corrplot(method = "color",
col = col(200),
type = "upper",
addCoef.col = "white",
diag = FALSE,
tl.col = "black",
tl.srt = 45,
outline = TRUE)
## Carry out principal component analysis
prot_pca <- cp_qf[["log_norm_proteins"]] %>%
filterNA() %>%
assay() %>%
t() %>%
prcomp(scale = TRUE, center = TRUE)
## Get a summary of the PCA
summary(prot_pca)
## Generate dataframe of each sample's PCA results
pca_df <- as.data.frame(prot_pca$x)
## Annotate samples with their corresponding condition
pca_df$condition <- cp_qf[["psms_raw"]]$condition
## Generate a PCA plot using PC1 and PC2
pca_df %>%
ggplot(aes(x = PC1, y = PC2, colour = condition)) +
geom_point(size = 4) +
scale_color_brewer(palette = "Set2") +
labs(colour = "Condition") +
geom_hline(yintercept = 0, linetype = "dashed") +
geom_vline(xintercept = 0, linetype = "dashed") +
guides(colour = guide_legend(override.aes = list(size = 3))) +
labs(x = "PC1 (42.5 %)", y = "PC2 (26.8 %)") +
ggtitle("Protein-level PCA plot") +
xlim(-100, 100) +
ylim(-100, 100) +
coord_fixed(ratio = 1) +
theme_bw()
## Verify
colData(cp_qf)
cp_qf[["psms_raw"]] %>% assay() %>% head()
