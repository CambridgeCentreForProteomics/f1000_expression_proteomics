as_tibble() %>%
pull(Quan.Info) %>%
table()
## Find out how many PSMs we expect to lose
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
dplyr::count(Number.of.Protein.Groups != 1)
## Remove these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ Number.of.Protein.Groups == 1,
i = "psms_filtered")
## Find out how many PSMs we expect to lose
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
dplyr::count(Rank != 1)
## Drop these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ Rank == 1,
i = "psms_filtered")
## Find out how many PSMs we expect to lose
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
dplyr::count(Search.Engine.Rank != 1)
## Drop these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ Search.Engine.Rank == 1,
i = "psms_filtered")
## Find out how many PSMs we expect to lose
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
dplyr::count(PSM.Ambiguity != "Unambiguous")
## No PSMs to remove so proceed
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Confidence) %>%
table()
## Import protein-level data
protein_cp <- read.delim(file = "cell_pellet_tmt_results_proteins.txt")
## Check column names
protein_cp %>%
names()
protein_cp %>%
pull(Protein.FDR.Confidence.Combined) %>%
table()
## Extract master protein accessions from our PSM-level data
proteins_in_data <- cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
select(Master.Protein.Accessions)
## Extract protein accessions and corresponding confidence from search output file
protein_search_output <- protein_cp %>%
select(Accession, Protein.FDR.Confidence.Combined)
## Combine data
protein_fdr <- left_join(x = proteins_in_data,
y = protein_search_output,
by = c("Master.Protein.Accessions" = "Accession"))
protein_fdr %>%
head()
rowData(cp_qf[["psms_filtered"]])$Protein.Confidence <- protein_fdr$Protein.FDR.Confidence.Combined
cp_qf <- cp_qf %>%
filterFeatures(~ Protein.Confidence == "High", i = "psms_filtered")
## Get summary information
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Average.Reporter.SN) %>%
summary()
## Plot histogram of reporter ion signal-to-noise
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
ggplot(aes(x = log10(Average.Reporter.SN))) +
geom_histogram(binwidth = 0.05) +
geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
labs(x = "log10(average reporter SN)", y = "Frequency") +
ggtitle("Average reporter ion S/N") +
theme_bw()
## Find out how many PSMs we expect to lose
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
dplyr::count(Average.Reporter.SN < 10)
## Drop these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ Average.Reporter.SN >= 10,
na.rm = TRUE,
i = "psms_filtered")
## Get summary information
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Isolation.Interference.in.Percent) %>%
summary()
## Plot histogram of co-isolation interference
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
ggplot(aes(x = Isolation.Interference.in.Percent)) +
geom_histogram(binwidth = 2) +
geom_vline(xintercept = 75, linetype = "dashed", color = "red") +
labs(x = "Isolation inteference (%)", y = "Frequency") +
ggtitle("Co-isolation interference %") +
theme_bw()
## Find out how many PSMs we expect to lose
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
dplyr::count(Isolation.Interference.in.Percent > 75)
## Remove these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ Isolation.Interference.in.Percent <= 75,
na.rm = TRUE,
i = "psms_filtered")
## Drop these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ SPS.Mass.Matches.in.Percent >= 65,
na.rm = TRUE,
i = "psms_filtered")
## Determine whether there are any NA values in the data
cp_qf[["psms_filtered"]] %>%
assay() %>%
anyNA()
## Determine the amount and distribution of NA values in the data
cp_qf[["psms_filtered"]] %>%
nNA()
## Plot histogram to visualize the distribution of NAs
nNA(cp_qf[["psms_filtered"]])$nNAcols %>%
as_tibble() %>%
mutate(Condition = c("Control", "Treated", "Treated",
"Control", "Control", "Treated")) %>%
ggplot(aes(x = name, y = (pNA * 100 ), group = Condition, fill = Condition)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Sample", y = "Missing values (%)") +
theme_bw()
## Get indices of rows which contain NA
rows_with_na_indices <- which(nNA(cp_qf[["psms_filtered"]])$nNArows$nNA != 0)
## Subset rows with NA
rows_with_na <- cp_qf[["psms_filtered"]][rows_with_na_indices, ]
## Inspect rows with NA
assay(rows_with_na)
## Check how many PSMs we will remove
nNA(cp_qf[["psms_filtered"]])$nNArows %>%
as_tibble() %>%
dplyr::count(pNA >= 0.2)
## Remove PSMs with more than 20 % (0.2) NA values
cp_qf <- cp_qf %>%
filterNA(pNA = 0.2,
i = "psms_filtered")
## log2 transform quantitative data
cp_qf <- logTransform(object = cp_qf,
base = 2,
i = "psms_filtered",
name = "log_psms")
## Verify
cp_qf
## Aggregate PSM to peptide
cp_qf <- aggregateFeatures(cp_qf,
i = "log_psms",
fcol = "Sequence",
name = "log_peptides",
fun = MsCoreUtils::robustSummary,
na.rm = TRUE)
## Verify
cp_qf
## Confirm the presence of NaN
assay(cp_qf[["log_peptides"]]) %>%
is.nan() %>%
table()
## Replace NaN with NA
assay(cp_qf[["log_peptides"]])[is.nan(assay(cp_qf[["log_peptides"]]))] <- NA
## Aggregate peptides to protein
cp_qf <- aggregateFeatures(cp_qf,
i = "log_peptides",
fcol = "Master.Protein.Accessions",
name = "log_proteins",
fun = MsCoreUtils::robustSummary,
na.rm = TRUE)
## Verify
cp_qf
## Aggregate from PSM directly to protein
cp_qf <- aggregateFeatures(cp_qf,
i = "psms_filtered",
fcol = "Master.Protein.Accessions",
name = "proteins_direct",
fun = MsCoreUtils::robustSummary,
na.rm = TRUE)
## normalize the log transformed peptide data
cp_qf <- normalize(cp_qf,
i = "log_proteins",
name = "log_norm_proteins",
method = "center.median")
## Verify
cp_qf
## Evaluate the effect of data normalization
pre_norm <- cp_qf[["log_proteins"]] %>%
assay() %>%
longFormat() %>%
mutate(Condition = ifelse(colname %in% c("S1", "S2", "S3"),
"Treated", "Control")) %>%
ggplot(aes(x = colname, y = value, fill = Condition)) +
geom_boxplot() +
labs(x = "Sample", y = "log2(abundance)", title = "Pre-normalization") +
theme_bw()
post_norm <- cp_qf[["log_norm_proteins"]] %>%
assay() %>%
longFormat() %>%
mutate(Condition = ifelse(colname %in% c("S1", "S2", "S3"),
"Treated", "Control")) %>%
ggplot(aes(x = colname, y = value, fill = Condition)) +
geom_boxplot() +
labs(x = "Sample", y = "log2(abundance)", title = "Post-normalization") +
theme_bw()
(pre_norm + theme(legend.position = "none")) +
post_norm & plot_layout(guides = "collect")
cp_qf
## Evaluate the effect of data normalization
pre_norm <- cp_qf[["log_proteins"]] %>%
assay() %>%
longFormat() %>%
mutate(Condition = ifelse(colname %in% c("S1", "S2", "S3"),
"Treated", "Control")) %>%
ggplot(aes(x = colname, y = value, fill = Condition)) +
geom_boxplot() +
labs(x = "Sample", y = "log2(abundance)", title = "Pre-normalization") +
theme_bw()
post_norm <- cp_qf[["log_norm_proteins"]] %>%
assay() %>%
longFormat() %>%
mutate(Condition = ifelse(colname %in% c("S1", "S2", "S3"),
"Treated", "Control")) %>%
ggplot(aes(x = colname, y = value, fill = Condition)) +
geom_boxplot() +
labs(x = "Sample", y = "log2(abundance)", title = "Post-normalization") +
theme_bw()
(pre_norm + theme(legend.position = "none")) +
post_norm & plot_layout(guides = "collect")
library(patchwork)
(pre_norm + theme(legend.position = "none")) +
post_norm & plot_layout(guides = "collect")
post_norm <- cp_qf[["log_norm_proteins"]] %>%
assay() %>%
longFormat() %>%
mutate(Condition = ifelse(colname %in% c("S1", "S2", "S3"),
"Treated", "Control"),
colname = factor(colname, levels = paste0("S", 1:6))) %>%
ggplot(aes(x = colname, y = value, fill = Condition)) +
geom_boxplot() +
labs(x = "Sample", y = "log2(abundance)", title = "Post-normalization") +
theme_bw()
(pre_norm + theme(legend.position = "none")) +
post_norm & plot_layout(guides = "collect")
## Evaluate the effect of data normalization
pre_norm <- cp_qf[["log_proteins"]] %>%
assay() %>%
longFormat() %>%
mutate(Condition = ifelse(colname %in% c("S1", "S2", "S3"),
"Treated", "Control"),
colname = factor(colname, levels = paste0("S", 1:6))) %>%
ggplot(aes(x = colname, y = value, fill = Condition)) +
geom_boxplot() +
labs(x = "Sample", y = "log2(abundance)", title = "Pre-normalization") +
theme_bw()
(pre_norm + theme(legend.position = "none")) +
post_norm & plot_layout(guides = "collect")
## visualize the process of log transformation and normalization
par(mfrow = c(1, 3))
cp_qf[["psms_filtered"]] %>%
assay() %>%
plotDensities(legend = "topright",
main = "Raw PSMs")
cp_qf[["log_psms"]] %>%
assay() %>%
plotDensities(legend = FALSE,
main = "log2(PSMs)")
cp_qf[["log_norm_proteins"]] %>%
assay() %>%
plotDensities(legend = FALSE,
main = "log2(norm proteins)")
library("QFeatures")
library("ggplot2")
library("stringr")
library("dplyr")
library("tibble")
library("NormalyzerDE")
library("corrplot")
library("Biostrings")
library("limma")
library("org.Hs.eg.db")
library("clusterProfiler")
library("enrichplot")
## visualize the process of log transformation and normalization
par(mfrow = c(1, 3))
cp_qf[["psms_filtered"]] %>%
assay() %>%
plotDensities(legend = "topright",
main = "Raw PSMs")
cp_qf[["log_psms"]] %>%
assay() %>%
plotDensities(legend = FALSE,
main = "log2(PSMs)")
cp_qf[["log_norm_proteins"]] %>%
assay() %>%
plotDensities(legend = FALSE,
main = "log2(norm proteins)")
## Add assay links from log_norm_proteins to psms_raw
cp_qf <- addAssayLink(object = cp_qf,
from = "psms_raw",
to = "log_norm_proteins",
varFrom = "Master.Protein.Accessions",
varTo = "Master.Protein.Accessions")
## Verify
assayLink(cp_qf,
i = "log_norm_proteins")
## Subset all data linked to the protein with accession Q01581
Q01581 <- subsetByFeature(cp_qf, "Q01581")
## Verify
Q01581
## Define conditions
treament <- c("S1", "S2", "S3")
control <- c("S4", "S5", "S6")
## Plot abundance distributions across samples at PSM, peptide and protein-level
Q01581[, , c("log_psms", "log_peptides", "log_proteins")] %>%
longFormat() %>%
as_tibble() %>%
mutate(assay_order = factor(
assay,
levels = c("log_psms", "log_peptides", "log_proteins"),
labels = c("PSMs", "Peptides", "Protein")),
condition = ifelse(colname %in% control, "control", "treatment")) %>%
ggplot(aes(x = colname, y = value, colour = assay)) +
geom_point(size = 3) +
geom_line(aes(group = rowname)) +
scale_x_discrete(limits = paste0("S", 1:6)) +
facet_wrap(~assay_order) +
labs(x = "Sample", y = "Abundance") +
ggtitle("log2 Q01581 abundance profiles") +
theme_bw()
## Convert TMT CP protein assay into a dataframe
prot_df <- cp_qf[["log_norm_proteins"]] %>%
assay() %>%
as.data.frame()
## Calculate a correlation matrix between samples
corr_matrix <- cor(prot_df,
method = "pearson",
use = "pairwise.complete.obs")
print(corr_matrix)
## Plot correlation between two samples - S1 and S2 used as example
prot_df %>%
ggplot(aes(x = `S1`, y = `S2`)) +
geom_point(colour = "grey45", size = 0.5) +
geom_abline(intercept = 0, slope = 1) +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
plot.background = element_rect(fill = "white"),
panel.background = element_rect(fill = "white"),
axis.title.x = element_text(size = 15, vjust = -2),
axis.title.y = element_text(size = 15, vjust = 3),
axis.text.x = element_text(size = 12, vjust = -1),
axis.text.y = element_text(size = 12),
axis.line = element_line(linewidth = 0.5, colour = "black"),
plot.margin = margin(10, 10, 10, 10)) +
xlim(-7.5, 5) +
ylim(-7.5, 5) +
labs(x = "log2(abundance S1)", y = "log2(abundance S2)") +
coord_fixed(ratio = 1)
## Create colour palette for continuum
col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF",
"#77AADD", "#4477AA"))
## Plot all pairwise correlations
prot_df %>%
cor(method = "pearson",
use = "pairwise.complete.obs") %>%
corrplot(method = "color",
col = col(200),
type = "upper",
addCoef.col = "white",
diag = FALSE,
tl.col = "black",
tl.srt = 45,
outline = TRUE)
prot_df
## Carry out principal component analysis
prot_pca <- cp_qf[["log_norm_proteins"]] %>%
filterNA() %>%
assay() %>%
t() %>%
prcomp(scale = TRUE, center = TRUE)
## Get a summary of the PCA
summary(prot_pca)
## Generate dataframe of each sample's PCA results
pca_df <- as.data.frame(prot_pca$x)
## Annotate samples with their corresponding condition
pca_df$condition <- cp_qf[["psms_raw"]]$condition
## Generate a PCA plot using PC1 and PC2
pca_df %>%
ggplot(aes(x = PC1, y = PC2, colour = condition)) +
geom_point(size = 4) +
scale_color_brewer(palette = "Set2") +
labs(colour = "Condition") +
geom_hline(yintercept = 0, linetype = "dashed") +
geom_vline(xintercept = 0, linetype = "dashed") +
guides(colour = guide_legend(override.aes = list(size = 3))) +
labs(x = "PC1 (42.5 %)", y = "PC2 (26.8 %)") +
ggtitle("Protein-level PCA plot") +
xlim(-100, 100) +
ylim(-100, 100) +
coord_fixed(ratio = 1) +
theme_bw()
## Extract protein-level data and associated colData
cp_proteins <- cp_qf[["log_norm_proteins"]]
colData(cp_proteins) <- colData(cp_qf[["log_norm_proteins"]])
## Create factor of interest
cp_proteins$condition <- factor(cp_proteins$condition)
## Check which level of the factor is the reference level and correct
cp_proteins$condition
cp_proteins$condition <- relevel(cp_proteins$condition, ref = "Control")
## Design a matrix containing all of the factors we wish to model the effects of
model_design <- model.matrix(~ cp_proteins$condition)
## Verify
print(model_design)
## Create a linear model using this design
fitted_lm <- cp_proteins %>%
assay() %>%
lmFit(design = model_design)
## Update the model based on Limma eBayes algorithm
fitted_lm <- eBayes(fit = fitted_lm,
trend = TRUE)
## Save results of the test
limma_results <- topTable(fit = fitted_lm,
coef = "cp_proteins$conditionTreated",
adjust.method = "BH",
number = Inf) %>%
rownames_to_column("Protein") %>%
as_tibble() %>%
mutate(TP = grepl("ups", Protein))
## Plot residual SD against average log abundance
plotSA(fitted_lm,
xlab = "Average log2(abundance)",
ylab = "log2(sigma)",
cex = 0.5)
## Plot histogram of raw p-values
limma_results %>%
ggplot(aes(x = P.Value)) +
geom_histogram(binwidth = 0.025) +
labs(x = "P-value", y = "Frequency") +
ggtitle("P-value distribution following Limma eBayes trend model") +
theme_bw()
## Look at limma results table
head(limma_results)
## Add direction of log fold change relative to control
limma_results$direction <- ifelse(limma_results$logFC > 0,
"up", "down") %>%
as.factor()
## Add significance thresholds
limma_results$significance <- ifelse(limma_results$adj.P.Val < 0.01,
"sig", "not.sig") %>%
as.factor()
## Verify
str(limma_results)
## Get a summary of statistically significant results
fitted_lm %>%
decideTests(adjust.method = "BH",
p.value = 0.01) %>%
summary()
## Generate a volcano plot
limma_results %>%
ggplot(aes(x = logFC, y = -log10(P.Value))) +
geom_point(aes(colour = significance:direction), size = 0.5) +
scale_color_manual(
values = c("black", "black", "deepskyblue", "red"), name = "",
labels = c("Downregulated insignificant",
"Upregulated insignificant",
"Downregulated significant",
"Upregulated significant")) +
theme(axis.title.x = element_text(size = 15, vjust = -2),
axis.title.y = element_text(size = 15, vjust = 2),
axis.text.x = element_text(size = 12, vjust = -1),
axis.text.y = element_text(size = 12),
plot.background = element_rect(fill = "white"),
panel.background = element_rect(fill = "white"),
axis.line = element_line(linewidth = 0.5, colour = "black"),
plot.margin = margin(10, 10, 10, 10),
legend.position = c(0.25, 0.9)) +
labs(x = "log2(FC)", y = "-log10(p-value)") +
xlim(-3.1, 3.1)
## Generate MA plot
limma_results %>%
ggplot(aes(x = AveExpr, y = logFC)) +
geom_point(aes(colour = significance:direction), size = 0.5) +
scale_color_manual(
values = c("black", "black", "deepskyblue", "red"), name = "",
labels = c("Downregulated insignificant",
"Upregulated insignificant",
"Downregulated significant",
"Upregulated significant")) +
theme(axis.title.x = element_text(size = 15, vjust = -2),
axis.title.y = element_text(size = 15, vjust = 2),
axis.text.x = element_text(size = 12, vjust = -1),
axis.text.y = element_text(size = 12),
plot.background = element_rect(fill = "white"),
panel.background = element_rect(fill = "white"),
axis.line = element_line(linewidth = 0.5, colour = "black"),
plot.margin = margin(10, 10, 10, 10),
legend.position = c(0.25, 0.9)) +
xlab("log2(mean abundance)") +
ylab("log2(FC)") +
xlim(-5, 3.5)
