regmatches(conts$desc, .)
# Chunk 36: tmt_cont_removal_2
## Define function to find contaminants
find_cont <- function(se, cont_acc) {
cont_indices <- c()
for (i in 1:length(cont_acc)) {
cont_protein <- cont_acc[i]
cont_present <- grep(cont_protein, rowData(se)$Protein.Accessions)
output <- c(cont_present)
cont_indices <- append(cont_indices, output)
}
cont_psm_indices <- cont_indices
}
## Store row indices of PSMs matched to a contaminant-containing protein group
cont_psms <- find_cont(cp_qf[["psms_filtered"]], cont_acc)
## If we find contaminants, remove these rows from the data
if (length(cont_psms) > 0)
cp_qf[["psms_filtered"]] <- cp_qf[["psms_filtered"]][-cont_psms, ]
# Chunk 37: tmt_no_quant_1
## Find out how many PSMs we expect to lose
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
dplyr::count(Quan.Info == "NoQuanLabels")
# Chunk 38: tmt_no_quant_2
## Drop these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ !Quan.Info == "NoQuanLabels",
i = "psms_filtered")
# Chunk 39: tmt_quan_info
## Are there any remaining annotations in the Quan.Info column?
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Quan.Info) %>%
table()
# Chunk 40: tmt_unique_1
## Find out how many PSMs we expect to lose
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
dplyr::count(Number.of.Protein.Groups != 1)
# Chunk 41: tmt_unique_2
## Remove these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ Number.of.Protein.Groups == 1,
i = "psms_filtered")
# Chunk 42: tmt_rank_1
## Find out how many PSMs we expect to lose
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
dplyr::count(Rank != 1)
# Chunk 43: tmt_rank_2
## Drop these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ Rank == 1,
i = "psms_filtered")
# Chunk 44: tmt_rank_3
## Find out how many PSMs we expect to lose
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
dplyr::count(Search.Engine.Rank != 1)
# Chunk 45: tmt_rank_4
## Drop these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ Search.Engine.Rank == 1,
i = "psms_filtered")
# Chunk 46: table3
tabl3 <- data.frame("PSM category" = c("Unambiguous",
"Selected",
"Rejected",
"Ambiguous",
"Unconsidered"),
"Definition" = c("The only candidate PSM",
"PSM was selected from a group of candidates",
"PSM was rejected from a group of candidates",
"Two or more candidate PSMs could not be distinguished",
"PSM was not considered suitable"))
knitr::kable(tabl3,
col.names = c("PSM category",
"Definition"),
caption = "Definitions of PSM ambiguity categories based on Proteome Discoverer outputs.")
# Chunk 47: tmt_ambiguity
## Find out how many PSMs we expect to lose
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
dplyr::count(PSM.Ambiguity != "Unambiguous")
## No PSMs to remove so proceed
# Chunk 48
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Confidence) %>%
table()
# Chunk 49
## Import protein-level data
protein_cp <- read.delim(file = "cell_pellet_tmt_results_proteins.txt")
## Check column names
protein_cp %>%
names()
# Chunk 50
protein_cp %>%
pull(Protein.FDR.Confidence.Combined) %>%
table()
# Chunk 51
## Extract master protein accessions from our PSM-level data
proteins_in_data <- cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
select(Master.Protein.Accessions)
## Extract protein accessions and corresponding confidence from search output file
protein_search_output <- protein_cp %>%
select(Accession, Protein.FDR.Confidence.Combined)
# Chunk 52
## Combine data
protein_fdr <- left_join(x = proteins_in_data,
y = protein_search_output,
by = c("Master.Protein.Accessions" = "Accession"))
protein_fdr %>%
head()
# Chunk 53
rowData(cp_qf[["psms_filtered"]])$Protein.Confidence <- protein_fdr$Protein.FDR.Confidence.Combined
# Chunk 54
cp_qf <- cp_qf %>%
filterFeatures(~ Protein.Confidence == "High", i = "psms_filtered")
# Chunk 55: tmt_filtering_summary_1
## Determine number and proportion of PSMs removed
psms_remaining <- cp_qf[["psms_filtered"]] %>%
nrow() %>%
as.numeric()
psms_removed <- original_psms - psms_remaining
psms_removed_prop <- ((psms_removed / original_psms) * 100) %>%
round(digits = 2)
## Determine number and proportion of peptides removed
peps_remaining <- cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Sequence) %>%
unique() %>%
length() %>%
as.numeric()
peps_removed <- original_peps - peps_remaining
peps_removed_prop <- ((peps_removed / original_peps) * 100) %>%
round(digits = 2)
## Determine number and proportion of proteins removed
prots_remaining <- cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Master.Protein.Accessions) %>%
unique() %>%
length() %>%
as.numeric()
prots_removed <- original_prots - prots_remaining
prots_removed_prop <- ((prots_removed / original_prots) * 100) %>%
round(digits = 2)
# Chunk 56: tmt_filtering_summary_2
## Print as a table
data.frame("Feature" = c("PSMs",
"Peptides",
"Proteins"),
"Number lost" = c(psms_removed,
peps_removed,
prots_removed),
"Percentage lost" = c(psms_removed_prop,
peps_removed_prop,
prots_removed_prop))
# Chunk 57: tmt_sn_ratio_1
## Get summary information
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Average.Reporter.SN) %>%
summary()
# Chunk 58: tmt_sn_ratio_2
## Plot histogram of reporter ion signal-to-noise
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
ggplot(aes(x = log10(Average.Reporter.SN))) +
geom_histogram(binwidth = 0.05) +
geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
labs(x = "log10(average reporter SN)", y = "Frequency") +
ggtitle("Average reporter ion S/N") +
theme_bw()
# Chunk 59: tmt_SN_ratio_3.
## Find out how many PSMs we expect to lose
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
dplyr::count(Average.Reporter.SN < 10)
# Chunk 60: tmt_SN_ratio_4
## Drop these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ Average.Reporter.SN >= 10,
na.rm = TRUE,
i = "psms_filtered")
# Chunk 61: tmt_coisolation_1
## Get summary information
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Isolation.Interference.in.Percent) %>%
summary()
# Chunk 62: tmt_coisolation_2
## Plot histogram of co-isolation interference
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
ggplot(aes(x = Isolation.Interference.in.Percent)) +
geom_histogram(binwidth = 2) +
geom_vline(xintercept = 75, linetype = "dashed", color = "red") +
labs(x = "Isolation inteference (%)", y = "Frequency") +
ggtitle("Co-isolation interference %") +
theme_bw()
# Chunk 63: tmt_coisolation_3
## Find out how many PSMs we expect to lose
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
dplyr::count(Isolation.Interference.in.Percent > 75)
# Chunk 64: tmt_coisolation_4
## Remove these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ Isolation.Interference.in.Percent <= 75,
na.rm = TRUE,
i = "psms_filtered")
# Chunk 65: tmt_sps_matches_1
## Get summary information
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(SPS.Mass.Matches.in.Percent) %>%
summary()
# Chunk 66: tmt_sps_matches_2
## Plot histogram of SPS mass match %
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
ggplot(aes(x = SPS.Mass.Matches.in.Percent)) +
geom_histogram(binwidth = 10) +
geom_vline(xintercept = 65, linetype = "dashed", color = "red") +
labs(x = "SPS mass matches (%)", y = "Frequency") +
scale_x_continuous(breaks = seq(0, 100, 10)) +
ggtitle("SPS mass match %") +
theme_bw()
# Chunk 67: tmt_sps_matches_3
## Find out how many PSMs we expect to lose
cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
dplyr::count(SPS.Mass.Matches.in.Percent < 65)
# Chunk 68: tmt_sps_matches_4
## Drop these rows from the data
cp_qf <- cp_qf %>%
filterFeatures(~ SPS.Mass.Matches.in.Percent >= 65,
na.rm = TRUE,
i = "psms_filtered")
# Chunk 69: tmt_filtering_summary_3
## Summarize the effect of data-specific filtering
## Determine the number and proportion of PSMs removed
psms_remaining_2 <- cp_qf[["psms_filtered"]] %>%
nrow() %>%
as.numeric()
psms_removed_2 <- psms_remaining - psms_remaining_2
psms_removed_prop_2 <- ((psms_removed_2 / original_psms) * 100) %>%
round(digits = 2)
## Determine number and proportion of peptides removed
peps_remaining_2 <- rowData(cp_qf[["psms_filtered"]])$Sequence %>%
unique() %>%
length() %>%
as.numeric()
peps_removed_2 <- peps_remaining - peps_remaining_2
peps_removed_prop_2 <- ((peps_removed_2 / original_peps) * 100) %>%
round(digits = 2)
## Determine number and proportion of proteins removed
prots_remaining_2 <- cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Master.Protein.Accessions) %>%
unique() %>%
length() %>%
as.numeric()
prots_removed_2 <- prots_remaining - prots_remaining_2
prots_removed_prop_2 <- ((prots_removed_2 / original_prots) * 100) %>%
round(digits = 2)
## Print as a table
data.frame("Feature" = c("PSMs",
"Peptides (stripped)",
"Protein groups"),
"Number lost" = c(psms_removed_2,
peps_removed_2,
prots_removed_2),
"Percentage lost" = c(psms_removed_prop_2,
peps_removed_prop_2,
prots_removed_prop_2))
# Chunk 70: tmt_missing_data_1
## Determine whether there are any NA values in the data
cp_qf[["psms_filtered"]] %>%
assay() %>%
anyNA()
## Determine the amount and distribution of NA values in the data
cp_qf[["psms_filtered"]] %>%
nNA()
# Chunk 71: tmt_missing_data_2
## Plot histogram to visualize the distribution of NAs
nNA(cp_qf[["psms_filtered"]])$nNAcols %>%
as_tibble() %>%
mutate(Condition = c("Control", "Treated", "Treated",
"Control", "Control", "Treated")) %>%
ggplot(aes(x = name, y = (pNA * 100 ), group = Condition, fill = Condition)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Sample", y = "Missing values (%)") +
theme_bw()
# Chunk 72: tmt_missing_data_3
## Find out the range of missing values per PSM
nNA(cp_qf[["psms_filtered"]])$nNArows$nNA %>%
table()
# Chunk 73: tmt_missing_data_4
## Get indices of rows which contain NA
rows_with_na_indices <- which(nNA(cp_qf[["psms_filtered"]])$nNArows$nNA != 0)
## Subset rows with NA
rows_with_na <- cp_qf[["psms_filtered"]][rows_with_na_indices, ]
## Inspect rows with NA
assay(rows_with_na)
# Chunk 74: tmt_missing_data_5
## Check how many PSMs we will remove
nNA(cp_qf[["psms_filtered"]])$nNArows %>%
as_tibble() %>%
dplyr::count(pNA >= 0.2)
# Chunk 75: tmt_missing_data_6
## Remove PSMs with more than 20 % (0.2) NA values
cp_qf <- cp_qf %>%
filterNA(pNA = 0.2,
i = "psms_filtered")
# Chunk 76: tmt_filtering_summary_4
## Determine final number of PSMs, peptides and master proteins
psms_final <- cp_qf[["psms_filtered"]] %>%
nrow() %>%
as.numeric()
psms_removed_total <- original_psms - psms_final
psms_removed_total_prop <- ((psms_removed_total / original_psms) * 100) %>%
round(digits = 2)
peps_final <- cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Sequence) %>%
unique() %>%
length() %>%
as.numeric()
peps_removed_total <- original_peps - peps_final
peps_removed_total_prop <- ((peps_removed_total / original_peps) * 100) %>%
round(digits = 2)
prots_final <- cp_qf[["psms_filtered"]] %>%
rowData() %>%
as_tibble() %>%
pull(Master.Protein.Accessions) %>%
unique() %>%
length() %>%
as.numeric()
prots_removed_total <- original_prots - prots_final
prots_removed_total_prop <- ((prots_removed_total / original_prots) * 100) %>%
round(digits = 2)
## Print as table
data.frame("Feature" = c("PSMs",
"Peptides (stripped)",
"Protein groups"),
"Number lost" = c(psms_removed_total,
peps_removed_total,
prots_removed_total),
"Percentage lost" = c(psms_removed_total_prop,
peps_removed_total_prop,
prots_removed_total_prop),
"Number remaining" = c(psms_final,
peps_final,
prots_final))
# Chunk 77: tmt_log_transform
## log2 transform quantitative data
cp_qf <- logTransform(object = cp_qf,
base = 2,
i = "psms_filtered",
name = "log_psms")
## Verify
cp_qf
# Chunk 78: tmt_psm_to_peptide
## Aggregate PSM to peptide
cp_qf <- aggregateFeatures(cp_qf,
i = "log_psms",
fcol = "Sequence",
name = "log_peptides",
fun = MsCoreUtils::robustSummary,
na.rm = TRUE)
# Chunk 79: tmt_psm_to_peptide_check
## Verify
cp_qf
# Chunk 80: NaN_to_NA_peptide
## Confirm the presence of NaN
assay(cp_qf[["log_peptides"]]) %>%
is.nan() %>%
table()
## Replace NaN with NA
assay(cp_qf[["log_peptides"]])[is.nan(assay(cp_qf[["log_peptides"]]))] <- NA
# Chunk 81: tmt_peptide_to_protein_agg
## Aggregate peptides to protein
cp_qf <- aggregateFeatures(cp_qf,
i = "log_peptides",
fcol = "Master.Protein.Accessions",
name = "log_proteins",
fun = MsCoreUtils::robustSummary,
na.rm = TRUE)
# Chunk 82: tmt_peptide_to_protein_agg_check
## Verify
cp_qf
# Chunk 83: tmt_normalization_1
## normalize the log transformed peptide data
cp_qf <- normalize(cp_qf,
i = "log_proteins",
name = "log_norm_proteins",
method = "center.median")
## Verify
cp_qf
# Chunk 84: tmt_normalization_2
## Evaluate the effect of data normalization
pre_norm <- cp_qf[["log_proteins"]] %>%
assay() %>%
longFormat() %>%
mutate(Condition = ifelse(colname %in% c("S1", "S2", "S3"),
"Treated", "Control"),
colname = factor(colname, levels = paste0("S", 1:6))) %>%
ggplot(aes(x = colname, y = value, fill = Condition)) +
geom_boxplot() +
labs(x = "Sample", y = "log2(abundance)", title = "Pre-normalization") +
theme_bw()
post_norm <- cp_qf[["log_norm_proteins"]] %>%
assay() %>%
longFormat() %>%
mutate(Condition = ifelse(colname %in% c("S1", "S2", "S3"),
"Treated", "Control"),
colname = factor(colname, levels = paste0("S", 1:6))) %>%
ggplot(aes(x = colname, y = value, fill = Condition)) +
geom_boxplot() +
labs(x = "Sample", y = "log2(abundance)", title = "Post-normalization") +
theme_bw()
(pre_norm + theme(legend.position = "none")) +
post_norm & plot_layout(guides = "collect")
# Chunk 85: tmt_transformations
## visualize the process of log transformation and normalization
par(mfrow = c(1, 3))
cp_qf[["psms_filtered"]] %>%
assay() %>%
plotDensities(legend = "topright",
main = "Raw PSMs")
cp_qf[["log_psms"]] %>%
assay() %>%
plotDensities(legend = FALSE,
main = "log2(PSMs)")
cp_qf[["log_norm_proteins"]] %>%
assay() %>%
plotDensities(legend = FALSE,
main = "log2(norm proteins)")
# Chunk 86: add_assay_links
## Add assay links from log_norm_proteins to psms_raw
cp_qf <- addAssayLink(object = cp_qf,
from = "psms_raw",
to = "log_norm_proteins",
varFrom = "Master.Protein.Accessions",
varTo = "Master.Protein.Accessions")
## Verify
assayLink(cp_qf,
i = "log_norm_proteins")
## Subset all data linked to the protein with accession Q01581
Q01581 <- subsetByFeature(cp_qf, "Q01581")
## Verify
Q01581
## Define conditions
treament <- c("S1", "S2", "S3")
control <- c("S4", "S5", "S6")
## Plot abundance distributions across samples at PSM, peptide and protein-level
Q01581[, , c("log_psms", "log_peptides", "log_proteins")] %>%
longFormat() %>%
as_tibble() %>%
mutate(assay_order = factor(
assay,
levels = c("log_psms", "log_peptides", "log_proteins"),
labels = c("PSMs", "Peptides", "Protein")),
condition = ifelse(colname %in% control, "control", "treatment")) %>%
ggplot(aes(x = colname, y = value, colour = assay)) +
geom_point(size = 3) +
geom_line(aes(group = rowname)) +
scale_x_discrete(limits = paste0("S", 1:6)) +
facet_wrap(~assay_order) +
labs(x = "Sample", y = "Abundance") +
ggtitle("log2 Q01581 abundance profiles") +
theme_bw()
## Plot peptide support per protein - .n in the proteins SE
cp_qf[["log_proteins"]] %>%
rowData() %>%
as_tibble() %>%
ggplot(aes(x = .n)) +
geom_histogram(binwidth = 1, boundary = 0.5) +
labs(x = "Peptide support (shown up to 20)",
y = "Frequency") +
scale_x_continuous(expand = c(0, 0),
limits = c(0, 20.5),
breaks = seq(1, 20, 1)) +
scale_y_continuous(expand = c(0, 0),
limits = c(0, 1100),
breaks = seq(0, 1100, 100)) +
ggtitle("Peptide support per protein") +
theme_bw()
